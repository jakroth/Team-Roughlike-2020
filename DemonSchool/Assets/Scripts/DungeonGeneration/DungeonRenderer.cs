using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DungeonRenderer : MonoBehaviour
{
    // INSTANTIATES the MAP and the TILES, based on the coordinates and room IDs generated in DungeonGenerator

    // will hold these objects from the hierarchy
    DungeonManager dungeonManager;
    DungeonGenerator dungeonGenerator;

    // the prefab for all the Tiles, set in the Inspector
    public GameObject tilePrefab;

    // cell dimensions, set in the Inspector (needs to always be 2 for now)
    // used everywhere we need to deal with size and movement
    public float cellDimensions;

    // choose which sprite list you need
    public enum chooseSpriteList { HellBorder, HellWall, HellFill, HellFloor, SchoolBorder, SchoolWall, SchoolFill, SchoolFloor };

    // textures for the hell walls around the border of the map
    public List<Sprite> hellBorderTextures;

    // textures for the floors of the map
    public List<Sprite> hellFloorTextures;

    // links tile texture sprites to tileIDs, set in the Inspector
    public List<Sprite> floorTileTextures;    // links tile texture sprites to tileIDs, set in the Inspector

    // some IDs for the texture/sprite of rooms
    // set in the Inspector
    public int basicFloorTileID;
    public int corridorTileID;
    public int backgroundTileID;

    // toggles between basic floor tiles and fire/ice/water floor tiles
    public bool basicFloorTilesOnly;

    // links wall texture sprites to wallIDs, set in the Inspector
    public List<Sprite> wallTileTextures;

    // some IDs for the texture/sprite of walls/doors
    // set in the Inspector
    public int doorTileID;
    public int wallTileID;

    // 2D array of tiles (made from the tilePrefab)
    public GameObject[,] tileMap;

    // the map dimensions
    // private, set in DungeonManager, obtained in spawnMap() method
    private int mapWidth = 0, mapHeight = 0;

    // create dictionary to hold the mapping of DungeonGenerator mapIDs to tileIDs
    private Dictionary<int, int> roomTilePairs;

    // used to randomly pick a room tileset from the Floor Tile Textures array if basicOnly is false
    public List<int> randomFloorIDs;

    // map coordinate names, from DungeonGenerator
    private int door = -3;
    private int wall = -2;
    private int corridor = -1;
    private int empty = 0;
    private int room = 1;


    // **************** ENTRY POINT for the DUNGEON RENDERER ****************
    // RENDERS the appropriate textures/sprites for each of the map coordinates generated by the DungeonGenerator
    public void spawnMap()
    {
        // grab the instance of the Dungeon Manager
        if (dungeonManager == null)
        {
            dungeonManager = DungeonManager.Instance;
        }
        // grab the Dungeon Generator object
        dungeonGenerator = GetComponent<DungeonGenerator>();

        // create the base map with background tiles and border (wall) tiles only
        createBaseMap();

        // create dictionary to hold the mapping of mapIDs to tileIDs/textures
        roomTilePairs = new Dictionary<int, int>();
        // set all Corridors to have the CorridorTileID
        roomTilePairs.Add(-1, corridorTileID);
        // set all Walls to have the WallTileID
        roomTilePairs.Add(-2, wallTileID);
        // set all Doors to have the DoorTileID
        roomTilePairs.Add(-3, doorTileID);

        // set all Floors to have BasicFloorTileIDs if ticked, otherwise random tile types for each room
        for (int i = 1; i <= dungeonGenerator._roomCount; i++)
        {
            roomTilePairs.Add(i, basicFloorTilesOnly ? basicFloorTileID : randomFloorIDs[Random.Range(0, randomFloorIDs.Count)]);
        }

        // create all the special (ID'd) tiles
        populateMapWithTiles();

    }


    // CREATES BASE MAP with empty TILES ******
    // called by the spawnMap() method above
    // calls three other methods in this Class
    private void createBaseMap()
    {
        // delete old map, set new map size, reinstantiate map 2D array
        setMapSize();
        // fill the map with the basic fill tiles
        fillGridObject();
        // fill the border with wall tiles
        fillBorderObject2();
    }


    // called by the createBaseMap() method above
    // setup a new map 2D array with no tile game objects
    private void setMapSize()
    {
        // delete old map
        deleteMap();

        // get map dimensions from DungeonManager
        mapHeight = dungeonManager.mapHeight;
        mapWidth = dungeonManager.mapWidth;

        // make new map
        tileMap = new GameObject[mapWidth, mapHeight];
    }


    // called by the setMapSize() method above, to clear the map before making a new map 
    // destroys all the tile objects in the 2D array "map"
    private void deleteMap()
    {
        for (int x = 0; x < mapWidth; x++)
        {
            for (int y = 0; y < mapHeight; y++)
            {
                if (tileMap[x, y] != null)
                {
                    Destroy(tileMap[x, y]);
                }
            }
        }
    }


    // called by the createBaseMap() method above
    // fills the map with the basic fill tiles
    private void fillGridObject()
    {
        // set grid as 1,1 to mapWidth-2,mapHeight-2
        Vector2Int start = new Vector2Int(1, 1);
        Vector2Int end = new Vector2Int(mapWidth - 2, mapHeight - 2);

        // check if proposed grid is outside map dimensions
        if (isPositionOutsideMap(start) || isPositionOutsideMap(end))
        {
            Debug.Log("Error fillGridObject. Grid outside map area. (" + start.x + ", " + start.y + ") to (" + end.x + ", " + end.y + ")");
            return;
        }

        // in case end is less than start
        int start_X = Mathf.Min(start.x, end.x);
        int start_Y = Mathf.Min(start.y, end.y);
        int end_X = Mathf.Max(start.x, end.x);
        int end_Y = Mathf.Max(start.y, end.y);


        // main loop for this method
        // creates basic fill tiles across the whole map
        for (int x = start_X; x <= end_X; x++)
        {
            for (int y = start_Y; y <= end_Y; y++)
            {
                createTile2(1, new Vector2Int(x, y), chooseSpriteList.HellFloor);
            }
        }
    }


    // called by the createBaseMap() method above
    // creates border tiles around the edges of the map
    private void fillBorderObject()
    {
        // set border as 0,0 to mapWidth -1,mapHeight-1
        Vector2Int start = new Vector2Int(0, 0);
        Vector2Int end = new Vector2Int(mapWidth - 1, mapHeight - 1);

        // check if proposed border is outside map dimensions
        if (isPositionOutsideMap(start) || isPositionOutsideMap(end))
        {
            Debug.Log("Error fillGridObject. Grid outside map area. (" + start.x + ", " + start.y + ") to (" + end.x + ", " + end.y + ")");
            return;
        }

        // in case end is less than start
        int start_X = Mathf.Min(start.x, end.x);
        int start_Y = Mathf.Min(start.y, end.y);
        int end_X = Mathf.Max(start.x, end.x);
        int end_Y = Mathf.Max(start.y, end.y);


        // main loop for this method
        // creates border tiles around the edges
        // top and bottom borders
        for (int x = start_X; x <= end_X; x++)
        {
            createTile(wallTileID, new Vector2Int(x, start_Y), true);
            createTile(wallTileID, new Vector2Int(x, end_Y), true);
        }
        // left and right borders
        for (int y = start_Y + 1; y < end_Y; y++)
        {
            createTile(wallTileID, new Vector2Int(start_X, y), true);
            createTile(wallTileID, new Vector2Int(end_X, y), true);
        }
    }


    // used by the fill...Object() methods above, to check if any of the tile (x,y) variables are outside the map boundaries
    private bool isPositionOutsideMap(Vector2Int pos)
    {
        return (pos.x > mapWidth - 1 || pos.x < 0 || pos.y > mapHeight - 1 || pos.y < 0);
    }



    // called by the createBaseMap() method above
    // creates border tiles around the edges of the map
    private void fillBorderObject2()
    {
        // setup variables
        int left_X = 0;
        int bottom_Y = 0;
        int right_X = mapWidth - 1;
        int top_Y = mapHeight - 1;

        // a useful variable for the loops below
        bool needsTJoin = false;

        // make corners
        createTile2(0, new Vector2Int(left_X, top_Y), chooseSpriteList.HellBorder);
        createTile2(1, new Vector2Int(right_X, top_Y), chooseSpriteList.HellBorder);
        createTile2(2, new Vector2Int(left_X, bottom_Y), chooseSpriteList.HellBorder);
        createTile2(3, new Vector2Int(right_X, bottom_Y), chooseSpriteList.HellBorder);

        // make borders
        for (int x = left_X + 1; x < right_X; x++)
        {
            // top border
            // check if TJoin needed (if adjacent tile is a wall or door, and either side of adjacent is a room, corridor or door)
            // OLD CODE: new List<int> { wall, door }.Contains(dungeonGenerator.map[x, top_Y - 1]); 
            needsTJoin = (dungeonGenerator.map[x, top_Y - 1] == wall || dungeonGenerator.map[x, top_Y - 1] == door) &&
                                (dungeonGenerator.map[x - 1, top_Y - 1] >= room || dungeonGenerator.map[x + 1, top_Y - 1] >= room ||
                                dungeonGenerator.map[x - 1, top_Y - 1] == corridor || dungeonGenerator.map[x + 1, top_Y - 1] == corridor);
            createTile2(needsTJoin ? 8 : 4, new Vector2Int(x, top_Y), chooseSpriteList.HellBorder);

            // bottom border
            needsTJoin = (dungeonGenerator.map[x, bottom_Y + 1] == wall || dungeonGenerator.map[x, bottom_Y + 1] == door) &&
                                (dungeonGenerator.map[x - 1, bottom_Y + 1] >= room || dungeonGenerator.map[x + 1, bottom_Y + 1] >= room ||
                                dungeonGenerator.map[x - 1, bottom_Y + 1] == corridor || dungeonGenerator.map[x + 1, bottom_Y + 1] == corridor);
            createTile2(needsTJoin ? 9 : 5, new Vector2Int(x, bottom_Y), chooseSpriteList.HellBorder);
        }

        for (int y = bottom_Y + 1; y < top_Y; y++)
        {
            // left border
            needsTJoin = (dungeonGenerator.map[left_X + 1, y] == wall || dungeonGenerator.map[left_X + 1, y] == door) &&
                                (dungeonGenerator.map[left_X + 1, y - 1] >= room || dungeonGenerator.map[left_X + 1, y + 1] >= room ||
                                dungeonGenerator.map[left_X + 1, y - 1] == corridor || dungeonGenerator.map[left_X + 1, y + 1] == corridor);
            createTile2(needsTJoin ? 10 : 6, new Vector2Int(left_X, y), chooseSpriteList.HellBorder);

            // right border
            needsTJoin = (dungeonGenerator.map[right_X - 1, y] == wall || dungeonGenerator.map[right_X - 1, y] == door) &&
                                (dungeonGenerator.map[right_X - 1, y - 1] >= room || dungeonGenerator.map[right_X - 1, y + 1] >= room ||
                                dungeonGenerator.map[right_X - 1, y - 1] == corridor || dungeonGenerator.map[right_X - 1, y + 1] == corridor);
            createTile2(needsTJoin ? 11 : 7, new Vector2Int(right_X, y), chooseSpriteList.HellBorder);
        }

    }


    // CREATES TILES on MAP BASED on their IDs ******
    // called by the spawnMap() method above
    private void populateMapWithTiles()
    {
        // Render the associated tile type/texture for each map coordinate
        for (int x = 0; x < mapWidth; x++)
        {
            for (int y = 0; y < mapHeight; y++)
            {
                // if mapID is a corridor or room, isWall = false
                if (dungeonGenerator.map[x, y] == corridor || dungeonGenerator.map[x, y] >= room)
                {
                    // grab the mapID from map[x,y] and check what tileID it's associated with in roomTilePairs
                    // send the (x,y) coordinates as a Vector2Int, along with the tileID, to the createTile method in the DungeonManager
                    createTile(roomTilePairs[dungeonGenerator.map[x, y]], new Vector2Int(x, y), false);
                }
                // else if mapID is a wall or door, isWall = true
                else if (dungeonGenerator.map[x, y] <= wall)
                {
                    createTile(roomTilePairs[dungeonGenerator.map[x, y]], new Vector2Int(x, y), true);
                }
            }
        }
        // set finalDoor variable in the assigned tile in the final room
        int finalRoom = dungeonGenerator.rooms.Count - 1;
        if (finalRoom > -1)
            tileMap[dungeonGenerator.rooms[finalRoom].door.x, dungeonGenerator.rooms[finalRoom].door.y].GetComponent<DungeonTile>().isFinalDoor = true;
    }



    // CREATES TILES on MAP BASED on their IDs ******
    // called by the spawnMap() method above
    private void populateMapWithTiles2()
    {
        // Render the associated tile type/texture for each map coordinate
        for (int x = 0; x < mapWidth; x++)
        {
            for (int y = 0; y < mapHeight; y++)
            {
                // if mapID is a corridor or room, isWall = false
                if (dungeonGenerator.map[x, y] == corridor || dungeonGenerator.map[x, y] >= room)
                {
                    // grab the mapID from map[x,y] and check what tileID it's associated with in roomTilePairs
                    // send the (x,y) coordinates as a Vector2Int, along with the tileID, to the createTile method in the DungeonManager
                    createTile2(roomTilePairs[dungeonGenerator.map[x, y]], new Vector2Int(x, y), chooseSpriteList.HellFloor);
                }
                // else if mapID is a wall or door, isWall = true
                else if (dungeonGenerator.map[x, y] <= wall)
                {
                    createTile2(roomTilePairs[dungeonGenerator.map[x, y]], new Vector2Int(x, y), chooseSpriteList.HellWall);
                }
            }
        }
        // set finalDoor variable in the assigned tile in the final room
        int finalRoom = dungeonGenerator.rooms.Count - 1;
        if (finalRoom > -1)
            tileMap[dungeonGenerator.rooms[finalRoom].door.x, dungeonGenerator.rooms[finalRoom].door.y].GetComponent<DungeonTile>().isFinalDoor = true;
    }




    // ************* TILE INSTANTIATION ************
    // actually instantiates the game objects/textures that are the map tiles
    // called by createBaseMap and it's helper methods to setup the basic floor and border tiles    
    // then called by populateMapWithTiles to make the room, inner wall, door and other special tiles
    private void createTile(int spriteIndex, Vector2Int pos, bool isDoorOrWall)
    {
        // check if this tile has already been instantiated (e.g. by the fillGrid or fillBorder methods)
        if (tileMap[pos.x, pos.y] == null)
        {
            // instantiate new tilePrefab game object on the map
            tileMap[pos.x, pos.y] = Instantiate(tilePrefab, new Vector3(pos.x * cellDimensions, pos.y * cellDimensions, 0), Quaternion.identity, dungeonManager._tileParent);
        }
        // set the tile ID, position and isWall to the one passed in
        tileMap[pos.x, pos.y].GetComponent<DungeonTile>().setTile(spriteIndex, pos, isDoorOrWall);
    }


    // ************* TILE INSTANTIATION ************
    // actually instantiates the game objects/textures that are the map tiles
    // called by createBaseMap and it's helper methods to setup the basic floor and border tiles    
    // then called by populateMapWithTiles to make the room, inner wall, door and other special tiles
    private void createTile2(int spriteIndex, Vector2Int pos, chooseSpriteList choice)
    {
        // check if this tile has already been instantiated (e.g. by the fillGrid or fillBorder methods)
        if (tileMap[pos.x, pos.y] == null)
        {
            // instantiate new tilePrefab game object on the map
            tileMap[pos.x, pos.y] = Instantiate(tilePrefab, new Vector3(pos.x * cellDimensions, pos.y * cellDimensions, 0), Quaternion.identity, dungeonManager._tileParent);
        }


        // set the tile ID, position and isWall to the one passed in
        tileMap[pos.x, pos.y].GetComponent<DungeonTile>().setTile2(spriteIndex, pos, (int)choice);
    }

}
