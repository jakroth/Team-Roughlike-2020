using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DungeonRenderer : MonoBehaviour
{
    // INSTANTIATES the MAP and the TILES, based on the coordinates and room IDs generated in DungeonGenerator

    // will hold these objects from the hierarchy
    DungeonManager dungeonManager;
    DungeonGenerator dungeonGenerator;

    // the prefab for all the Tiles, set in the Inspector
    public GameObject tilePrefab;

    // cell dimensions, set in the Inspector (needs to always be 2 for now)
    // used everywhere we need to deal with size and movement
    public float cellDimensions;


    // 2D array of floor tiles (made from the tilePrefab)
    [HideInInspector] public GameObject[,] floorTileMap;

    // 2D array of wall tiles (made from the tilePrefab)
    [HideInInspector] public GameObject[,] wallTileMap;

    // 2D array of wall shadow tiles (made from the tilePrefab)
    [HideInInspector] public GameObject[,] shadowTileMap;


    [Header("Hell Sprites")]
    // tile set for the Hell Tiles
    public List<Sprite> hellTiles;

    [Header("Normal Sprites")]
    // tile set for the Normal Tiles
    public List<Sprite> normalTiles;

    [Header("Wall Sprite Indexes")]
    public int topLeftCornerTile;
    public int topRightCornerTile;
    public int bottomLeftCornerTile;
    public int bottomRightCornerTile;
    public int topStraightTile;
    public int bottomStraightTile;
    public int leftStraightTile;
    public int rightStraightTile;
    public int topTJoinTile;
    public int bottomTJoinTile;
    public int leftTJoinTile;
    public int rightTJoinTile;
    public int fourWayTile;
    public int doorTile;
    public int doorwayTile;

    [Header("Shadow/Fill Sprite Indexes")]
    public int floorTile;
    public int fullWallFillTile;
    public int dividedWallFillTile;
    public int leftWallFillTile;
    public int rightWallFillTile;
    public int doorFillTile;
    public int doorwayFillTile;
    public int endWallFillTile;
    public int closedDoorFillTile;


    [Header("Sorting Layers")]
    public string floorLayer;
    public string wallLayer;
    public string shadowLayer;


    // links tile texture sprites to tileIDs, set in the Inspector
    public List<Sprite> floorTileTextures;   

    
    // some IDs for the texture/sprite of rooms
    // set in the Inspector
    public int basicFloorTileID;
    public int corridorTileID;
    public int backgroundTileID;

    // toggles between basic floor tiles and fire/ice/water floor tiles
    public bool basicFloorTilesOnly;

    // links wall texture sprites to wallIDs, set in the Inspector
    public List<Sprite> wallTileTextures;

    // some IDs for the texture/sprite of walls/doors
    // set in the Inspector
    public int doorTileID;
    public int wallTileID;


    // the map dimensions
    // private, set in DungeonManager, obtained in spawnMap() method
    private int mapWidth = 0, mapHeight = 0;

    // create dictionary to hold the mapping of DungeonGenerator mapIDs to tileIDs
    private Dictionary<int, int> roomTilePairs;

    // used to randomly pick a room tileset from the Floor Tile Textures array if basicOnly is false
    public List<int> randomFloorIDs;

    // map coordinate names, from DungeonGenerator
    private readonly int DOOR = -3;
    private readonly int WALL = -2;
    private readonly int CORRIDOR = -1;
    private readonly int ROOM = 1;


    // **************** ENTRY POINT for the DUNGEON RENDERER ****************
    // RENDERS the appropriate textures/sprites for each of the map coordinates generated by the DungeonGenerator
    public void spawnMap()
    {
        // grab the instance of the Dungeon Manager
        if (dungeonManager == null)
        {
            dungeonManager = DungeonManager.Instance;
        }
        // grab the Dungeon Generator object
        dungeonGenerator = GetComponent<DungeonGenerator>();

        // create the base map with background tiles and border (wall) tiles only
        createBaseMap();

        // create dictionary to hold the mapping of mapIDs to tileIDs/textures
        roomTilePairs = new Dictionary<int, int>();
        // set all Corridors to have the CorridorTileID
        roomTilePairs.Add(CORRIDOR, corridorTileID);
        // set all Walls to have the WallTileID
        roomTilePairs.Add(WALL, wallTileID);
        // set all Doors to have the DoorTileID
        roomTilePairs.Add(DOOR, doorTileID);

        // set all Floors to have BasicFloorTileIDs if ticked, otherwise random tile types for each room
        for (int i = 1; i <= dungeonGenerator._roomCount; i++)
        {
            roomTilePairs.Add(i, basicFloorTilesOnly ? basicFloorTileID : randomFloorIDs[Random.Range(0, randomFloorIDs.Count)]);
        }

        // create all the special (ID'd) tiles
        populateMapWithTiles();


        // set finalDoor variable in the assigned tile in the final room
        int finalRoom = dungeonGenerator.rooms.Count - 1;
        if (finalRoom > -1)
            wallTileMap[dungeonGenerator.rooms[finalRoom].door.x, dungeonGenerator.rooms[finalRoom].door.y].GetComponent<DungeonTile>().isFinalDoor = true;
    }


    // CREATES BASE MAP with empty TILES ******
    // called by the spawnMap() method above
    // calls three other methods in this Class
    private void createBaseMap()
    {
        // delete old map, set new map size, reinstantiate map 2D array
        setMapSize();
        // fill the map with the basic fill tiles
        fillGridFloor();
        // fill the border with wall tiles
        createBorderWall();
    }


    // called by the createBaseMap() method above
    // setup a new map 2D array with no tile game objects
    private void setMapSize()
    {
        // delete old map
        deleteMap();

        // get map dimensions from DungeonManager
        mapHeight = dungeonManager.mapHeight;
        mapWidth = dungeonManager.mapWidth;

        // make new maps
        floorTileMap = new GameObject[mapWidth, mapHeight];
        wallTileMap = new GameObject[mapWidth, mapHeight];
        shadowTileMap = new GameObject[mapWidth, mapHeight];
    }


    // called by the setMapSize() method above, to clear the maps before making new maps 
    // destroys all the tile objects in the 2D "map" arrays 
    private void deleteMap()
    {
        for (int x = 0; x < mapWidth; x++)
        {
            for (int y = 0; y < mapHeight; y++)
            {
                if (floorTileMap[x, y] != null)
                {
                    Destroy(floorTileMap[x, y]);
                }
                if (wallTileMap[x, y] != null)
                {
                    Destroy(wallTileMap[x, y]);
                }
                if (shadowTileMap[x, y] != null)
                {
                    Destroy(shadowTileMap[x, y]);
                }
            }
        }
    }


    // called by the createBaseMap() method above
    // fills the map with the basic fill tiles
    private void fillGridFloor()
    {
        // setup variables
        int left_X = 1;
        int bottom_Y = 1;
        int right_X = mapWidth - 2;
        int top_Y = mapHeight - 2;

        // main loop for this method
        // creates basic fill tiles across the whole map
        for (int x = left_X; x <= right_X; x++)
        {
            for (int y = bottom_Y; y <= top_Y; y++)
            {
                createTile(floorTile, new Vector2Int(x, y), floorTileMap, floorLayer, false, false);
            }
        }
    }


    // called by the createBaseMap() method above
    // creates border tiles around the edges of the map
    private void createBorderWall()
    {
        // setup variables
        int left_X = 0;
        int bottom_Y = 0;
        int right_X = mapWidth - 1;
        int top_Y = mapHeight - 1;

        // a useful variable for the loops below
        bool needsTJoin;

        // make corners
        createTile(0, new Vector2Int(left_X, top_Y), wallTileMap, wallLayer, true, false);
        createTile(1, new Vector2Int(right_X, top_Y), wallTileMap, wallLayer, true, false);
        createTile(2, new Vector2Int(left_X, bottom_Y), wallTileMap, wallLayer, true, false);
        createTile(3, new Vector2Int(right_X, bottom_Y), wallTileMap, wallLayer, true, false);

        // make borders
        for (int x = left_X + 1; x < right_X; x++)
        {
            // top border
            // check if TJoin needed (if adjacent tile is a wall or door, and either side of adjacent is a room, corridor or door)
            needsTJoin = (dungeonGenerator.map[x, top_Y - 1] == WALL || dungeonGenerator.map[x, top_Y - 1] == DOOR) &&
                                (dungeonGenerator.map[x - 1, top_Y - 1] >= ROOM || dungeonGenerator.map[x + 1, top_Y - 1] >= ROOM ||
                                dungeonGenerator.map[x - 1, top_Y - 1] == CORRIDOR || dungeonGenerator.map[x + 1, top_Y - 1] == CORRIDOR);
            createTile(needsTJoin ? topTJoinTile : topStraightTile, new Vector2Int(x, top_Y), wallTileMap, wallLayer, true, false);

            // bottom border
            needsTJoin = (dungeonGenerator.map[x, bottom_Y + 1] == WALL || dungeonGenerator.map[x, bottom_Y + 1] == DOOR) &&
                                (dungeonGenerator.map[x - 1, bottom_Y + 1] >= ROOM || dungeonGenerator.map[x + 1, bottom_Y + 1] >= ROOM ||
                                dungeonGenerator.map[x - 1, bottom_Y + 1] == CORRIDOR || dungeonGenerator.map[x + 1, bottom_Y + 1] == CORRIDOR);
            createTile(needsTJoin ? bottomTJoinTile : bottomStraightTile, new Vector2Int(x, bottom_Y), wallTileMap, wallLayer, true, false);
        }

        for (int y = bottom_Y + 1; y < top_Y; y++)
        {
            // left border
            needsTJoin = (dungeonGenerator.map[left_X + 1, y] == WALL || dungeonGenerator.map[left_X + 1, y] == DOOR) &&
                                (dungeonGenerator.map[left_X + 1, y - 1] >= ROOM || dungeonGenerator.map[left_X + 1, y + 1] >= ROOM ||
                                dungeonGenerator.map[left_X + 1, y - 1] == CORRIDOR || dungeonGenerator.map[left_X + 1, y + 1] == CORRIDOR);
            createTile(needsTJoin ? leftTJoinTile : leftStraightTile, new Vector2Int(left_X, y), wallTileMap, wallLayer, true, false);

            // right border
            needsTJoin = (dungeonGenerator.map[right_X - 1, y] == WALL || dungeonGenerator.map[right_X - 1, y] == DOOR) &&
                                (dungeonGenerator.map[right_X - 1, y - 1] >= ROOM || dungeonGenerator.map[right_X - 1, y + 1] >= ROOM ||
                                dungeonGenerator.map[right_X - 1, y - 1] == CORRIDOR || dungeonGenerator.map[right_X - 1, y + 1] == CORRIDOR);
            createTile(needsTJoin ? rightTJoinTile : rightStraightTile, new Vector2Int(right_X, y), wallTileMap, wallLayer, true, false);
        }
    }


    // CREATES TILES on MAP BASED on their IDs ******
    // called by the spawnMap() method above
    private void populateMapWithTiles()
    {
        // Render the associated tile type/texture for each map coordinate
        for (int x = 0; x < mapWidth; x++)
        {
            for (int y = 0; y < mapHeight; y++)
            {
                // if mapID is a corridor or room, isCollision = false;
                if (dungeonGenerator.map[x, y] == CORRIDOR || dungeonGenerator.map[x, y] >= ROOM)
                {
                    // grab the mapID from map[x,y] and check what tileID it's associated with in roomTilePairs
                    // send the (x,y) coordinates as a Vector2Int, along with the tileID, to the createTile method in the DungeonManager
                    createTile(roomTilePairs[dungeonGenerator.map[x, y]], new Vector2Int(x, y), wallTileMap, wallLayer, false, true);
                }
                // else if mapID is a wall or door, isWall = true
                else if (dungeonGenerator.map[x, y] <= WALL)
                {
                    createTile(roomTilePairs[dungeonGenerator.map[x, y]], new Vector2Int(x, y), wallTileMap, wallLayer, true, true);
                }
            }
        }
    }



    // ************* TILE INSTANTIATION ************
    // actually instantiates the game objects/textures that are the map tiles
    // called by createBaseMap and it's helper methods to setup the basic floor and border tiles    
    // then called by populateMapWithTiles to make the room, inner wall, door and other special tiles
    private void createTile(int spriteIndex, Vector2Int pos, GameObject[,] map, string layer, bool isCollision, bool oldTiles)
    {
        // check if this tile has already been instantiated (e.g. by the fillGrid or fillBorder methods)
        if (map[pos.x, pos.y] == null)
        {
            // instantiate new tilePrefab game object on the map
            map[pos.x, pos.y] = Instantiate(tilePrefab, new Vector3(pos.x * cellDimensions, pos.y * cellDimensions, 0), Quaternion.identity, dungeonManager._tileParent);
        }
        // set the tile ID, position and isWall to the one passed in
        map[pos.x, pos.y].GetComponent<DungeonTile>().setTile(spriteIndex, pos, layer, isCollision, oldTiles);
    }


}
