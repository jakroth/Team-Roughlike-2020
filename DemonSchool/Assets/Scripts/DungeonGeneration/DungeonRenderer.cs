using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DungeonRenderer : MonoBehaviour
{
    // INSTANTIATES the MAP and the TILES, based on the coordinates and room IDs generated in DungeonGenerator

    // will hold these objects from the hierarchy
    DungeonManager dungeonManager;
    DungeonGenerator dungeonGenerator;

    // the prefab for all the Tiles, set in the Inspector
    public GameObject tilePrefab;

    // cell dimensions, set in the Inspector (needs to always be 2 for now)
    // used everywhere we need to deal with size and movement
    public float cellDimensions;

    // links tile texture sprites to tileIDs, set in the Inspector
    public List<Sprite> floorTileTextures;

    // some IDs for the texture/sprite of rooms
    // set in the Inspector
    public int basicFloorTileID;
    public int corridorTileID;
    public int backgroundTileID;

    // toggles between basic floor tiles and fire/ice/water floor tiles
    public bool basicFloorTilesOnly;

    // links wall texture sprites to wallIDs, set in the Inspector
    public List<Sprite> wallTileTextures;

    // some IDs for the texture/sprite of walls/doors
    // set in the Inspector
    public int doorTileID;
    public int wallTileID;

        // 2D array of tiles (made from the tilePrefab)
    public GameObject[,] tileMap;

    // the map dimensions
    // private, set in DungeonManager, obtained in spawnMap() method
    private int mapWidth = 0, mapHeight = 0;

    // create dictionary to hold the mapping of DungeonGenerator mapIDs to tileIDs
    private Dictionary<int, int> roomTilePairs;

    // used to randomly pick a room tileset from the Floor Tile Textures array if basicOnly is false
    public List<int> randomFloorIDs;





    // **************** ENTRY POINT for the DUNGEON RENDERER ****************
    // RENDERS the appropriate textures/sprites for each of the map coordinates generated by the DungeonGenerator
    public void spawnMap()
    {
        // grab the instance of the Dungeon Manager
        if (dungeonManager == null)
        {
            dungeonManager = DungeonManager.Instance;
        }
        // grab the Dungeon Generator object
        dungeonGenerator = GetComponent<DungeonGenerator>();

        // create the base map with background tiles and border (wall) tiles only
        createBaseMap();

        // create dictionary to hold the mapping of mapIDs to tileIDs/textures
        roomTilePairs = new Dictionary<int, int>();
        // set all Corridors to have the CorridorTileID
        roomTilePairs.Add(-1, corridorTileID);
        // set all Walls to have the WallTileID
        roomTilePairs.Add(-2, wallTileID);
        // set all Doors to have the DoorTileID
        roomTilePairs.Add(-3, doorTileID);

        // set all Floors to have BasicFloorTileIDs if ticked, otherwise random tile types for each room
        for (int i = 1; i <= dungeonGenerator._roomCount; i++)
        {
            roomTilePairs.Add(i, basicFloorTilesOnly ? basicFloorTileID : randomFloorIDs[Random.Range(0, randomFloorIDs.Count)]);
        }

        // create all the special (ID'd) tiles
        populateMapWithTiles();

    }


    // CREATES BASE MAP with empty TILES ******
    // called by the spawnMap() method above
    // calls three other methods in this Class
    private void createBaseMap()
    {
        // delete old map, set new map size, reinstantiate map 2D array
        setMapSize();
        // fill the map with the basic fill tiles
        fillGridObject();
        // fill the border with wall tiles
        fillBorderObject();
    }


    // called by the createBaseMap() method above
    // setup a new map 2D array with no tile game objects
    private void setMapSize()
    {
        // delete old map
        deleteMap();

        // get map dimensions from DungeonManager
        mapHeight = dungeonManager.mapHeight;
        mapWidth = dungeonManager.mapWidth;

        // make new map
        tileMap = new GameObject[mapWidth, mapHeight];
    }


    // called by the setMapSize() method above, to clear the map before making a new map 
    // destroys all the tile objects in the 2D array "map"
    private void deleteMap()
    {
        for (int x = 0; x < mapWidth; x++)
        {
            for (int y = 0; y < mapHeight; y++)
            {
                if (tileMap[x, y] != null)
                {
                    Destroy(tileMap[x, y]);
                }
            }
        }
    }


    // called by the createBaseMap() method above
    // fills the map with the basic fill tiles
    private void fillGridObject()
    {
        // set grid as 1,1 to mapWidth-2,mapHeight-2
        Vector2Int start = new Vector2Int(1, 1);
        Vector2Int end = new Vector2Int(mapWidth - 2, mapHeight - 2);

        // check if proposed grid is outside map dimensions
        if (isPositionOutsideMap(start) || isPositionOutsideMap(end))
        {
            Debug.Log("Error fillGridObject. Grid outside map area. (" + start.x + ", " + start.y + ") to (" + end.x + ", " + end.y + ")");
            return;
        }

        // in case end is less than start
        int start_X = Mathf.Min(start.x, end.x);
        int start_Y = Mathf.Min(start.y, end.y);
        int end_X = Mathf.Max(start.x, end.x);
        int end_Y = Mathf.Max(start.y, end.y);


        // main loop for this method
        // creates basic fill tiles across the whole map
        for (int x = start_X; x <= end_X; x++)
        {
            for (int y = start_Y; y <= end_Y; y++)
            {
                createTile(backgroundTileID, new Vector2Int(x, y), false);
            }
        }
    }


    // called by the createBaseMap() method above
    // creates border tiles around the edges of the map
    private void fillBorderObject()
    {
        // set border as 0,0 to mapWidth -1,mapHeight-1
        Vector2Int start = new Vector2Int(0, 0);
        Vector2Int end = new Vector2Int(mapWidth - 1, mapHeight - 1);

        // check if proposed border is outside map dimensions
        if (isPositionOutsideMap(start) || isPositionOutsideMap(end))
        {
            Debug.Log("Error fillGridObject. Grid outside map area. (" + start.x + ", " + start.y + ") to (" + end.x + ", " + end.y + ")");
            return;
        }

        // in case end is less than start
        int start_X = Mathf.Min(start.x, end.x);
        int start_Y = Mathf.Min(start.y, end.y);
        int end_X = Mathf.Max(start.x, end.x);
        int end_Y = Mathf.Max(start.y, end.y);


        // main loop for this method
        // creates border tiles around the edges
        // top and bottom borders
        for (int x = start_X; x <= end_X; x++)
        {
            createTile(wallTileID, new Vector2Int(x, start_Y), true);
            createTile(wallTileID, new Vector2Int(x, end_Y), true);
        }
        // left and right borders
        for (int y = start.y + 1; y < end_Y; y++)
        {
            createTile(wallTileID, new Vector2Int(start_X, y), true);
            createTile(wallTileID, new Vector2Int(end_X, y), true);
        }
    }


    // used by the fill...Object() methods above, to check if any of the tile (x,y) variables are outside the map boundaries
    private bool isPositionOutsideMap(Vector2Int pos)
    {
        return (pos.x > mapWidth - 1 || pos.x < 0 || pos.y > mapHeight - 1 || pos.y < 0);
    }




    // CREATES TILES on MAP BASED on their IDs ******
    // called by the spawnMap() method above
    private void populateMapWithTiles()
    {
        // Render the associated tile type/texture for each map coordinate
        for (int x = 0; x < mapWidth; x++)
        {
            for (int y = 0; y < mapHeight; y++)
            {
                // if mapID is a corridor or room, isWall = false
                if (dungeonGenerator.map[x, y] == -1 || dungeonGenerator.map[x, y] > 0)
                {
                    // grab the mapID from map[x,y] and check what tileID it's associated with in roomTilePairs
                    // send the (x,y) coordinates as a Vector2Int, along with the tileID, to the createTile method in the DungeonManager
                    createTile(roomTilePairs[dungeonGenerator.map[x, y]], new Vector2Int(x, y), false);
                }
                // else if mapID is a wall or door, isWall = true
                else if (dungeonGenerator.map[x, y] < -1)
                {
                    createTile(roomTilePairs[dungeonGenerator.map[x, y]], new Vector2Int(x, y), true);
                }
            }
        }
        // set finalDoor variable in the assigned tile in the final room
        int finalRoom = dungeonGenerator.rooms.Count - 1;
        if (finalRoom > -1)
            tileMap[dungeonGenerator.rooms[finalRoom].door.x, dungeonGenerator.rooms[finalRoom].door.y].GetComponent<DungeonTile>().isFinalDoor = true;
    }




    // ************* TILE INSTANTIATION ************
    // actually instantiates the game objects/textures that are the map tiles
    // called by createBaseMap method to setup the basic floor and border tiles    
    // then called by ...? to make the room, inner wall, door and other special tiles
    private void createTile(int tileID, Vector2Int pos, bool isDoorOrWall)
    {
        // check if this tile has already been instantiated (e.g. by the fillGrid or fillBorder methods)
        if (tileMap[pos.x, pos.y] == null)
        {
            // instantiate new tilePrefab game objects all over the map, where they don't already exists
            tileMap[pos.x, pos.y] = Instantiate(tilePrefab, new Vector3(pos.x * cellDimensions, pos.y * cellDimensions, 0), Quaternion.identity, dungeonManager._tileParent);
        }
        // set the tile ID, position and isWall to the one passed in
        tileMap[pos.x, pos.y].GetComponent<DungeonTile>().setTile(tileID, pos, isDoorOrWall);

    }

}
