using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class DungeonRenderer : MonoBehaviour
{
    // INSTANTIATES the MAP and the TILES, based on the coordinates and room IDs generated in DungeonGenerator

    // will hold these objects from the hierarchy
    DungeonManager dungeonManager;
    DungeonGenerator dungeonGenerator;

    // the prefab for all the Tiles, set in the Inspector
    public GameObject tilePrefab;

    // cell dimensions, set in the Inspector (needs to always be 2 for now)
    // used everywhere we need to deal with size and movement
    public float cellDimensions;

    private int[,] map;

    // 2D array of floor tiles (made from the tilePrefab)
    [HideInInspector] public GameObject[,] floorTileMap;

    // 2D array of wall tiles (made from the tilePrefab)
    [HideInInspector] public GameObject[,] wallTileMap;

    // 2D array of wall shadow tiles (made from the tilePrefab)
    [HideInInspector] public GameObject[,] shadowTileMap;


    [Header("Hell Sprites")]
    // tile set for the Hell Tiles
    public List<Sprite> hellTiles;

    [Header("Normal Sprites")]
    // tile set for the Normal Tiles
    public List<Sprite> normalTiles;

    [Header("Wall Sprite Indexes")]
    public int topLeftCornerTile;
    public int topRightCornerTile;
    public int bottomLeftCornerTile;
    public int bottomRightCornerTile;
    public int topStraightTile;
    public int bottomStraightTile;
    public int leftStraightTile;
    public int rightStraightTile;
    public int topTJoinTile;
    public int bottomTJoinTile;
    public int leftTJoinTile;
    public int rightTJoinTile;
    public int fourWayTile;
    public int doorTile;
    public int doorwayTile;

    [Header("Shadow/Fill Sprite Indexes")]
    public int floorTile;
    public int fullWallFillTile;
    public int dividedWallFillTile;
    public int leftWallFillTile;
    public int rightWallFillTile;
    public int doorFillTile;
    public int doorwayFillTile;
    public int endWallFillTile;
    public int closedDoorFillTile;
    public int fireTile;
    public int halfFireTile;


    [Header("Sorting Layers")]
    public string floorLayer;
    public string wallLayer;
    public string shadowLayer;


    // links tile texture sprites to tileIDs, set in the Inspector
    public List<Sprite> floorTileTextures;   

    
    // some IDs for the texture/sprite of rooms
    // set in the Inspector
    public int basicFloorTileID;
    public int corridorTileID;
    public int backgroundTileID;

    // toggles between basic floor tiles and fire/ice/water floor tiles
    public bool basicFloorTilesOnly;

    // links wall texture sprites to wallIDs, set in the Inspector
    public List<Sprite> wallTileTextures;

    // some IDs for the texture/sprite of walls/doors
    // set in the Inspector
    public int doorTileID;
    public int wallTileID;


    // the map dimensions
    // private, set in DungeonManager, obtained in spawnMap() method
    private int mapWidth = 0, mapHeight = 0;

    // create dictionary to hold the mapping of DungeonGenerator mapIDs to tileIDs
    private Dictionary<int, int> roomTilePairs;

    // used to randomly pick a room tileset from the Floor Tile Textures array if basicOnly is false
    public List<int> randomFloorIDs;

    // map coordinate names, from DungeonGenerator
    private readonly int DOOR = -3;
    private readonly int WALL = -2;
    private readonly int CORRIDOR = -1;
    private readonly int ROOM = 1;


    // **************** ENTRY POINT for the DUNGEON RENDERER ****************
    // RENDERS the appropriate textures/sprites for each of the map coordinates generated by the DungeonGenerator
    public void spawnMap()
    {
        // grab the instance of the Dungeon Manager
        if (dungeonManager == null)
        {
            dungeonManager = DungeonManager.Instance;
        }
        // grab the Dungeon Generator object
        dungeonGenerator = GetComponent<DungeonGenerator>();

        map = dungeonGenerator.map;

        // create the base map with background tiles and border (wall) tiles only
        createBaseMap();

        // create dictionary to hold the mapping of mapIDs to tileIDs/textures
        roomTilePairs = new Dictionary<int, int>();
        // set all Corridors to have the CorridorTileID
        roomTilePairs.Add(CORRIDOR, corridorTileID);
        // set all Walls to have the WallTileID
        roomTilePairs.Add(WALL, wallTileID);
        // set all Doors to have the DoorTileID
        roomTilePairs.Add(DOOR, doorTileID);

        // set all Floors to have BasicFloorTileIDs if ticked, otherwise random tile types for each room
        for (int i = 1; i <= dungeonGenerator._roomCount; i++)
        {
            roomTilePairs.Add(i, basicFloorTilesOnly ? basicFloorTileID : randomFloorIDs[Random.Range(0, randomFloorIDs.Count)]);
        }

        // create all the special (ID'd) tiles
        createFeaturedMap();


    }


    // CREATES BASE MAP with empty TILES ******
    // called by the spawnMap() method above
    // calls three other methods in this Class
    private void createBaseMap()
    {
        // delete old map, set new map size, reinstantiate map 2D array
        setMapSize();
        // fill the map with the basic fill tiles
        fillGridFloor();
        // fill the border with wall tiles
        createBorderWall();
    }



    private void createFeaturedMap()
    {
        //creates the tiles for the rooms and corridors, at layer 2, not collidable
        createRoomsAndCorridors();

        // creates the tiles for the walls, at layer 2, generally collidable
        createWalls();

        // creates the tiles for the doors, at layer 2, generally collidable
        //createDoors();

        // creates the tiles for the shadows, at layer 3, sometimes collidable
        createShadows();

    }



    // called by the createBaseMap() method above
    // setup a new map 2D array with no tile game objects
    private void setMapSize()
    {
        // delete old map
        deleteMap();

        // get map dimensions from DungeonManager
        mapHeight = dungeonManager.mapHeight;
        mapWidth = dungeonManager.mapWidth;

        // make new maps
        floorTileMap = new GameObject[mapWidth, mapHeight];
        wallTileMap = new GameObject[mapWidth, mapHeight];
        shadowTileMap = new GameObject[mapWidth, mapHeight];
    }



    // called by the setMapSize() method above, to clear the maps before making new maps 
    // destroys all the tile objects in the 2D "map" arrays 
    private void deleteMap()
    {
        for (int x = 0; x < mapWidth; x++)
        {
            for (int y = 0; y < mapHeight; y++)
            {
                if (floorTileMap[x, y] != null)
                {
                    Destroy(floorTileMap[x, y]);
                }
                if (wallTileMap[x, y] != null)
                {
                    Destroy(wallTileMap[x, y]);
                }
                if (shadowTileMap[x, y] != null)
                {
                    Destroy(shadowTileMap[x, y]);
                }
            }
        }
    }


    // called by the createBaseMap() method above
    // fills the map with the basic fill tiles
    private void fillGridFloor()
    {
        // setup variables
        int left_X = 1;
        int bottom_Y = 1;
        int right_X = mapWidth - 2;
        int top_Y = mapHeight - 2;

        // main loop for this method
        // creates basic fill tiles across the whole map
        for (int x = left_X; x <= right_X; x++)
        {
            for (int y = bottom_Y; y <= top_Y; y++)
            {
                if (map[x, y] != WALL) {
                    if (Random.Range(0, 2) == 0)
                        createTile(fireTile, new Vector2Int(x, y), floorTileMap, floorLayer, false, false);
                    else
                        createTile(halfFireTile, new Vector2Int(x, y), floorTileMap, floorLayer, false, false);
                }
            }
        }
    }


    // called by the createBaseMap() method above
    // creates border tiles around the edges of the map
    private void createBorderWall()
    {
        // setup variables
        int left_X = 0;
        int bottom_Y = 0;
        int right_X = mapWidth - 1;
        int top_Y = mapHeight - 1;

        // a useful variable for the loops below
        bool needsTJoin;

        // make corners
        createTile(topLeftCornerTile, new Vector2Int(left_X, top_Y), wallTileMap, wallLayer, true, false);
        createTile(topRightCornerTile, new Vector2Int(right_X, top_Y), wallTileMap, wallLayer, true, false);
        createTile(bottomLeftCornerTile, new Vector2Int(left_X, bottom_Y), wallTileMap, wallLayer, true, false);
        createTile(bottomRightCornerTile, new Vector2Int(right_X, bottom_Y), wallTileMap, wallLayer, true, false);

        // make borders
        for (int x = left_X + 1; x < right_X; x++)
        {
            // top border
            // check if TJoin needed (if adjacent tile is a wall or door, and either side of adjacent is a room, corridor or door)
            needsTJoin = (map[x, top_Y - 1] == WALL || map[x, top_Y - 1] == DOOR) &&
                                (map[x - 1, top_Y - 1] >= ROOM || map[x + 1, top_Y - 1] >= ROOM ||
                                map[x - 1, top_Y - 1] == CORRIDOR || map[x + 1, top_Y - 1] == CORRIDOR);
            createTile(needsTJoin ? topTJoinTile : topStraightTile, new Vector2Int(x, top_Y), wallTileMap, wallLayer, true, false);

            // bottom border
            needsTJoin = (map[x, bottom_Y + 1] == WALL || map[x, bottom_Y + 1] == DOOR) &&
                                (map[x - 1, bottom_Y + 1] >= ROOM || map[x + 1, bottom_Y + 1] >= ROOM ||
                                map[x - 1, bottom_Y + 1] == CORRIDOR || map[x + 1, bottom_Y + 1] == CORRIDOR);
            createTile(needsTJoin ? bottomTJoinTile : bottomStraightTile, new Vector2Int(x, bottom_Y), wallTileMap, wallLayer, true, false);
        }

        for (int y = bottom_Y + 1; y < top_Y; y++)
        {
            // left border
            needsTJoin = (map[left_X + 1, y] == WALL || map[left_X + 1, y] == DOOR) &&
                                (map[left_X + 1, y - 1] >= ROOM || map[left_X + 1, y + 1] >= ROOM ||
                                map[left_X + 1, y - 1] == CORRIDOR || map[left_X + 1, y + 1] == CORRIDOR);
            createTile(needsTJoin ? leftTJoinTile : leftStraightTile, new Vector2Int(left_X, y), wallTileMap, wallLayer, true, false);

            // right border
            needsTJoin = (map[right_X - 1, y] == WALL || map[right_X - 1, y] == DOOR) &&
                                (map[right_X - 1, y - 1] >= ROOM || map[right_X - 1, y + 1] >= ROOM ||
                                map[right_X - 1, y - 1] == CORRIDOR || map[right_X - 1, y + 1] == CORRIDOR);
            createTile(needsTJoin ? rightTJoinTile : rightStraightTile, new Vector2Int(right_X, y), wallTileMap, wallLayer, true, false);
        }
    }


    // create room and corridor tiles
    // called by the spawnMap() method above
    private void createRoomsAndCorridors()
    {
        // Render the associated tile type/texture for each map coordinate
        for (int x = 1; x <= mapWidth - 2; x++)
        {
            for (int y = 1; y <= mapHeight - 2; y++)
            {
                // if mapID is a corridor or room, isCollision = false;
                if (map[x, y] == CORRIDOR || map[x, y] >= ROOM)
                {
                    // grab the mapID from map[x,y] and check what tileID it's associated with in roomTilePairs
                    // send the (x,y) coordinates as a Vector2Int, along with the tileID, to the createTile method in the DungeonManager
                    createTile(roomTilePairs[map[x, y]], new Vector2Int(x, y), wallTileMap, wallLayer, false, true);
                }
                // else if mapID is a wall or door, isWall = true
                else if (map[x, y] <= WALL)
                {
                    createTile(roomTilePairs[map[x, y]], new Vector2Int(x, y), wallTileMap, wallLayer, true, true);
                }
            }
        }
    }


    // creates all the interior walls of the map at layer 2
    // these are generally collidable
    private void createWalls()
    {
        // create the associated tile type/texture for each map coordinate
        for (int x = 1; x <= mapWidth - 2; x++)
        {
            for (int y = 1; y <= mapHeight - 2; y++)
            {
                // CORNER WALLS x4
                // top left corner
                if (map[x, y] == WALL && (map[x + 1, y] == WALL || map[x + 1, y] == DOOR) && (map[x, y - 1] == WALL || map[x, y - 1] == DOOR) && (map[x - 1, y] != WALL || x - 1 <= 0) && (map[x, y + 1] != WALL || y + 1 >= mapHeight - 1))
                    createTile(topLeftCornerTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);

                // top right corner
                else if (map[x, y] == WALL && (map[x - 1, y] == WALL || map[x - 1, y] == DOOR) && (map[x, y - 1] == WALL || map[x, y - 1] == DOOR) && (map[x + 1, y] != WALL || x + 1 >= mapWidth - 1) && (map[x, y + 1] != WALL || y + 1 >= mapHeight - 1))
                    createTile(topRightCornerTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);

                // bottom left corner
                else if (map[x, y] == WALL && (map[x + 1, y] == WALL || map[x + 1, y] == DOOR) && (map[x, y + 1] == WALL || map[x, y + 1] == DOOR) && (map[x - 1, y] != WALL || x - 1 <= 0) && (map[x, y - 1] != WALL || y - 1 <= 0))
                    createTile(bottomLeftCornerTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);

                // bottom right corner
                else if (map[x, y] == WALL && (map[x - 1, y] == WALL || map[x - 1, y] == DOOR) && (map[x, y + 1] == WALL || map[x, y + 1] == DOOR) && (map[x + 1, y] != WALL || x + 1 >= mapWidth - 1) && (map[x, y - 1] != WALL || y - 1 <= 0))
                    createTile(bottomRightCornerTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);


                // STRAIGHT WALLS and T-JOINS (HORIZONTAL)
                else if (map[x, y] == WALL && (map[x + 1, y] == WALL || map[x + 1, y] == DOOR || x + 1 >= mapWidth - 1) && (map[x - 1, y] == WALL || map[x - 1, y] == DOOR || x - 1 <= 0))
                {
                    // horizontal straight
                    if ((map[x, y + 1] != WALL || y + 1 >= mapHeight - 1) && (map[x, y - 1] != WALL || y - 1 <= 0))
                        createTile(topStraightTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);
                    // top TJoin
                    else if ((map[x, y - 1] == WALL || map[x, y - 1] == DOOR || y - 1 <= 0) && (map[x, y + 1] != WALL || y + 1 >= mapHeight - 1))
                        createTile(topTJoinTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);
                    // bottom TJoin
                    else if (map[x, y + 1] == WALL || map[x, y + 1] == DOOR || y + 1 >= mapHeight - 1)
                        createTile(bottomTJoinTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);
                }


                // STRAIGHT WALLS and T-JOINS (VERTICAL)
                else if (map[x, y] == WALL && (map[x, y + 1] == WALL || map[x, y + 1] == DOOR || y + 1 >= mapHeight - 1) && (map[x, y - 1] == WALL || map[x, y - 1] == DOOR || y - 1 <= 0))
                {
                    // vertical straight
                    if ((map[x + 1, y] != WALL || x + 1 >= mapWidth - 1) && (map[x - 1, y] != WALL || x - 1 <= 0))
                        createTile(leftStraightTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);
                    // left TJoin
                    else if ((map[x + 1, y] == WALL || map[x + 1, y] == DOOR || x + 1 >= mapWidth - 1) && (map[x - 1, y] != WALL || x - 1 <= 0))
                        createTile(leftTJoinTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);
                    // right TJoin
                    else if ((map[x - 1, y] == WALL || map[x - 1, y] == DOOR || x - 1 <= 0) && (map[x + 1, y] != WALL || x + 1 >= mapWidth - 1))
                        createTile(rightTJoinTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);
                }


                // ENDINGS
                else if (map[x, y] == WALL)
                {
                    int count = 0;
                    if (map[x - 1, y] == WALL) count += 1;
                    if (map[x + 1, y] == WALL) count += 3;
                    if (map[x, y - 1] == WALL) count += 5;
                    if (map[x, y + 1] == WALL) count += 7;
                    if (count == 0 || count == 1 || count == 3)
                        createTile(topStraightTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);
                    else if (count == 5 || count == 7)
                        createTile(leftStraightTile, new Vector2Int(x, y), wallTileMap, wallLayer, true, false);                           
                }


                    // door ways?? 

                    // anything else? 
                                    
            }
        }
    }


    private void createDoors()
    {
        // set finalDoor variable in the assigned tile in the final room
        int finalRoom = dungeonGenerator.rooms.Count - 1;
        if (finalRoom > -1)
        {
            Vector2Int finalDoor = dungeonGenerator.rooms[finalRoom].door;
            Vector2Int firstDoor = dungeonGenerator.rooms[0].door;

            //horizontal door
            if (finalDoor.y <= 0 || finalDoor.y >= mapHeight - 1)
                createTile(doorTile, new Vector2Int(finalDoor.x, finalDoor.x), wallTileMap, wallLayer, true, false);
            else if (map[finalDoor.x-1, finalDoor.y] == WALL || map[finalDoor.x-1, finalDoor.y] == WALL)
                createTile(doorTile, new Vector2Int(finalDoor.x, finalDoor.x), wallTileMap, wallLayer, true, false);

            //vertical door
            if (finalDoor.x <=0 || finalDoor.x >= mapWidth -1)
                createTile(closedDoorFillTile, new Vector2Int(finalDoor.x, finalDoor.x), wallTileMap, wallLayer, true, false);
            else if (map[finalDoor.x, finalDoor.y-1] == WALL || map[finalDoor.x, finalDoor.y-1] == WALL)
                createTile(closedDoorFillTile, new Vector2Int(finalDoor.x, finalDoor.x), wallTileMap, wallLayer, true, false);

            //horizontal door
            if (firstDoor.y <= 0 || firstDoor.y >= mapHeight - 1)
                createTile(doorTile, new Vector2Int(firstDoor.x, firstDoor.x), wallTileMap, wallLayer, true, false);
            else if (map[firstDoor.x - 1, firstDoor.y] == WALL || map[firstDoor.x - 1, firstDoor.y] == WALL)
                createTile(doorTile, new Vector2Int(firstDoor.x, firstDoor.x), wallTileMap, wallLayer, true, false);

            //vertical door
            if (firstDoor.x <= 0 || firstDoor.x >= mapWidth - 1)
                createTile(closedDoorFillTile, new Vector2Int(firstDoor.x, firstDoor.x), wallTileMap, wallLayer, true, false);
            else if (map[firstDoor.x, firstDoor.y - 1] == WALL || map[firstDoor.x, firstDoor.y - 1] == WALL)
                createTile(closedDoorFillTile, new Vector2Int(firstDoor.x, firstDoor.x), wallTileMap, wallLayer, true, false);


            wallTileMap[dungeonGenerator.rooms[finalRoom].door.x, dungeonGenerator.rooms[finalRoom].door.y].GetComponent<DungeonTile>().isFinalDoor = true;
        }

    }


    // creates all the wall shadows on top of the wall layer. 
    // these are generally not collidable
    private void createShadows()
    {
        // Render the associated tile type/texture for each map coordinate
        for (int x = 0; x < mapWidth; x++)
        {
            for (int y = 0; y < mapHeight; y++)
            {




            }
        }

    }


    // ************* TILE INSTANTIATION ************
    // actually instantiates the game objects/textures that are the map tiles
    // called by createBaseMap and it's helper methods to setup the basic floor and border tiles    
    // then called by populateMapWithTiles to make the room, inner wall, door and other special tiles
    private void createTile(int spriteIndex, Vector2Int pos, GameObject[,] map, string layer, bool isCollision, bool oldTiles)
    {
        // check if this tile has already been instantiated (e.g. by the fillGrid or fillBorder methods)
        if (map[pos.x, pos.y] == null)
        {
            // instantiate new tilePrefab game object on the map
            map[pos.x, pos.y] = Instantiate(tilePrefab, new Vector3(pos.x * cellDimensions, pos.y * cellDimensions, 0), Quaternion.identity, dungeonManager._tileParent);
        }
        // set the tile ID, position and isWall to the one passed in
        map[pos.x, pos.y].GetComponent<DungeonTile>().setTile(spriteIndex, pos, layer, isCollision, oldTiles);
    }


}
